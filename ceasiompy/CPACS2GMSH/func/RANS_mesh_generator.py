"""
CEASIOMpy: Conceptual Aircraft Design Software

Developed by CFS ENGINEERING, 1015 Lausanne, Switzerland

Use .brep files parts of an airplane to generate a fused airplane in GMSH with
the OCC kernel. Then Spherical farfield is created around the airplane and the
resulting domain is meshed using gmsh

Python version: >=3.8

| Author: Guido Vallifuoco
| Creation: 2024-02-01

TODO:

    - It may be good to move all the function and some of the code in generategmsh()
    that are related to disk actuator to another python script and import it here

    - Add mesh sizing for each aircraft part and as consequence add marker

    - Integrate other parts during fragmentation

    - Use run software function instead subprocess.call

"""

# =================================================================================================
#   IMPORTS
# =================================================================================================

import os
import subprocess
from pathlib import Path

import gmsh
from ceasiompy.CPACS2GMSH.func.generategmesh import (
    # duplicate_disk_actuator_surfaces,
    # control_disk_actuator_normal,
    # get_entities_from_volume,
    ModelPart,
    add_disk_actuator,
    fuselage_size,
    wings_size,
    process_gmsh_log,
)
from ceasiompy.utils.ceasiomlogger import get_logger

from ceasiompy.CPACS2GMSH.func.advancemeshing import (
    refine_wing_section,
    min_fields,
)
from ceasiompy.CPACS2GMSH.func.wingclassification import (
    classify_wing,
)

from ceasiompy.utils.ceasiompyutils import get_part_type

from ceasiompy.utils.configfiles import ConfigFile

log = get_logger()

# =================================================================================================
#   FUNCTIONS
# =================================================================================================


def generate_2d_mesh_for_pentagrow(
    cpacs, cpacs_path, brep_dir, results_dir, open_gmsh, min_max_mesh_factor,
    fuselage_mesh_size_factor, wing_mesh_size_factor, mesh_size_engines, mesh_size_propellers,
):
    """
    Function to generate a mesh from brep files forming an airplane
    Function 'generate_gmsh' is a subfunction of CPACS2GMSH which return a
    mesh file useful for pentagrow.
    The airplane is fused with the different brep files : fuselage, wings and
    other parts are identified and fused together in order to obtain a watertight volume.
    Args:
    ----------
    cpacs : CPACS
        CPACS object
    cpacs_path : Path
        Path to the directory containing CPACS object
    brep_dir : Path
        Path to the directory containing the brep files
    results_dir : Path
        Path to the directory containing the result (mesh) files
    open_gmsh : bool
        Open gmsh GUI after the mesh generation if set to true
    min_max_mesh_factor : ?
        ? (TODO)
    fuselage_mesh_size_factor : float
        Factor of the fuselage mesh size : the mesh size will be the mean fuselage width divided by this factor
    wing_mesh_size_factor : float
        Factor of the wing mesh size : the mesh size will be the mean fuselage width divided by this factor
    mesh_size_engines : float
        Size of the engines mesh
    mesh_size_propellers : float
        Size of the propellers mesh
    ...
    Returns:
    ----------
    mesh_file : Path
        Path to the mesh file generated by gmsh


    """
    # Determine if rotor are present in the aircraft model
    rotor_model = False
    if Path(brep_dir, "config_rotors.cfg").exists():
        rotor_model = True

    if rotor_model:
        log.info("Adding disk actuator")
        config_file = ConfigFile(Path(brep_dir, "config_rotors.cfg"))
        add_disk_actuator(brep_dir, config_file)

    # Retrieve all brep
    brep_files = list(brep_dir.glob("*.brep"))
    brep_files.sort()

    # initialize gmsh
    gmsh.initialize()
    # Stop gmsh output log in the terminal
    gmsh.option.setNumber("General.Terminal", 0)
    # Log complexity
    gmsh.option.setNumber("General.Verbosity", 5)

    log.info(f"Importing files from {brep_dir}")

    # Import shapes and get the tags and name
    fuselage_volume_dimtags = []
    aircraft_parts = []
    for brep_file in brep_files:
        # Import the part and create the aircraft part object
        part_entities = gmsh.model.occ.importShapes(
            str(brep_file), highestDimOnly=False)
        gmsh.model.occ.synchronize()

        # Create the aircraft part object
        part_obj = ModelPart(uid=brep_file.stem)
        part_obj.part_type = get_part_type(cpacs.tixi, part_obj.uid)
        # part_obj.physical_groups = brep_file.name.replace('.brep', '')
        part_obj.volume = part_entities[0]
        part_obj.volume_tag = part_entities[0][1]
        # Want to get fuselage length to size our model
        if part_obj.part_type == "fuselage":
            fuselage_volume_dimtags.append(part_entities[0])
        aircraft_parts.append(part_obj)

    if (len(fuselage_volume_dimtags) < 1):
        # Don't know in which case it should happen but is here if needed
        model_bb = gmsh.model.get_bounding_box(-1, -1)
        log.info("Warning : no fuselage in this aircraft")
    else:
        # TODO if multiple fuselage? --> Take the longest?
        model_bb = gmsh.model.get_bounding_box(
            fuselage_volume_dimtags[0][0], fuselage_volume_dimtags[0][1]
        )

    # Compute dimensions of fuselage
    model_dimensions = [
        abs(model_bb[0] - model_bb[3]),
        abs(model_bb[1] - model_bb[4]),
        abs(model_bb[2] - model_bb[5]),
    ]
    gmsh.model.occ.synchronize()

    # Center everything around the center of the fuselage
    all_volumes = gmsh.model.getEntities(3)
    gmsh.model.occ.translate(
        all_volumes,
        -((model_bb[0]) + (model_dimensions[0] / 2)),
        -((model_bb[1]) + (model_dimensions[1] / 2)),
        -((model_bb[2]) + (model_dimensions[2] / 2)),
    )
    gmsh.model.occ.synchronize()

    log.info("Start manipulation to obtain a watertight volume")
    # we have to obtain a watertight volume, needed for tetgen (otherwise just can't start)

    # We then call the function to fuse the parts and create the named physical groups
    aircraft_parts = fusing_parts_and_surface_naming_for_2d_mesh(
        aircraft_parts, brep_files, cpacs, model_bb, model_dimensions)
    gmsh.model.occ.synchronize()
    log.info("Manipulation finished")

    # Mesh generation
    log.info("Start of gmsh 2D surface meshing process")

    # Compute fuselage and wing size for meshing
    fuselage_maxlen, fuselage_minlen = fuselage_size(cpacs_path)
    wing_maxlen, wing_minlen = wings_size(cpacs_path)

    # Store the computed value of mesh size to use later
    mesh_size_by_group = {}
    mesh_size_by_group["fuselage"] = (
        (fuselage_maxlen + fuselage_minlen) / 2) / fuselage_mesh_size_factor
    mesh_size_by_group["wing"] = ((wing_maxlen * 0.8 + wing_minlen) /
                                  2) / wing_mesh_size_factor
    mesh_size_by_group["engine"] = mesh_size_engines
    mesh_size_by_group["rotor"] = mesh_size_propellers

    log.info(
        f"Mesh size fuselage={  ((fuselage_maxlen + fuselage_minlen) / 2) / fuselage_mesh_size_factor :.3f} m")
    log.info(
        f"Mesh size wing={((wing_maxlen * 0.8 + wing_minlen) /2) / wing_mesh_size_factor:.3f} m")
    log.info(f"Mesh size engine={mesh_size_engines:.3f} m")
    log.info(f"Mesh size rotor={mesh_size_propellers:.3f} m")

    # Now fix the mesh size for every part
    for i in range(len(aircraft_parts)):
        model_part = aircraft_parts[i]
        # Take the right mesh size (name physical group should be wing or fuselage or engine or propeller)
        lc = mesh_size_by_group[model_part.part_type]

        # To choose the size, we create a field with constant value containing only our list of surfaces, and give it the size
        gmsh.model.mesh.field.add("Constant", i+1)
        gmsh.model.mesh.field.setNumbers(
            i+1, "SurfacesList", model_part.surfaces_tags)
        gmsh.model.mesh.field.setNumber(i+1, "VIn", lc)
        gmsh.model.mesh.field.setAsBackgroundMesh(i+1)

    # Now we combine our fields to get the total airplane mesh
    j = len(aircraft_parts)+1
    fields = [i for i in range(1, j+1)]
    gmsh.model.mesh.field.add("Min", j)
    gmsh.model.mesh.field.setNumbers(j, "FieldsList", fields)
    gmsh.model.mesh.field.setAsBackgroundMesh(j)
    gmsh.model.occ.synchronize()

    # Now do the refinement on the le and te
    refine_factor = 2
    if refine_factor != 1:
        aircraft = ModelPart("aircraft")

        # For all the wing, we call the function classify that will detect the le and te between all the lines and compute the mean chord length
        for model_part in aircraft_parts:
            if model_part.part_type == "wing":
                classify_wing(model_part, aircraft_parts)
                log.info(
                    f"Classification of {model_part.uid} done"
                    f" {len(model_part.wing_sections)} section(s) found "
                )

        # mesh fields contains all the nb alraedy used for some fields (used when set different sizes)
        mesh_fields = {"nbfields": j, "restrict_fields": [
            i for i in range(1, len(aircraft_parts)+2)]}
        # tag of the main volume constituing the aicraft
        final_domain_volume_tag = gmsh.model.occ.getEntities(3)[0][1]

        for model_part in aircraft_parts:
            if model_part.part_type == "wing":
                # Refine will set fields to have smaller mesh size along te and le
                refine_wing_section(
                    mesh_fields,
                    [final_domain_volume_tag],
                    # AAAAAH should aircraft have surfaces?
                    aircraft,
                    model_part,
                    mesh_size_by_group["wing"],
                    refine=refine_factor,
                    refine_truncated=False,
                )

        # Generate the minimal background mesh field
        mesh_fields = min_fields(mesh_fields)

    # Parameters for the meshing
    gmsh.option.setNumber("Mesh.MeshSizeFromCurvature", 0)
    gmsh.option.setNumber("Mesh.MeshSizeFromPoints", 0)
    gmsh.option.setNumber("Mesh.MeshSizeExtendFromBoundary", 0)
    gmsh.option.setNumber("Mesh.Algorithm", 6)
    gmsh.option.setNumber("Mesh.LcIntegrationPrecision", 1e-6)
    gmsh.option.setNumber("Mesh.StlOneSolidPerSurface", 2)

    # Generate the mesh
    gmsh.logger.start()
    gmsh.model.mesh.generate(1)
    gmsh.model.mesh.generate(2)

    process_gmsh_log(gmsh.logger.get())
    gmsh.model.occ.synchronize()

    log.info("Finished meshing surface")
    if open_gmsh:
        log.info("Result of 2D surface mesh")
        log.info("GMSH GUI is open, close it to continue...")
        gmsh.fltk.run()

    gmesh_path = Path(results_dir, "surface_mesh.stl")
    gmsh.write(str(gmesh_path))

    return gmesh_path, fuselage_maxlen


def intersecting_entities_for_fusing(
    parts_dimtag
):
    """
Function to find two entities (volumes) in the list that have a non-zero intersection
Usefull because to fuse need connecting entities
Args:
----------
parts_dimtags : list of tuples
    List of the dimension and tag of all the volumes we want to search in
...
Returns:
----------
(i,j, True) : tuple (int,int,bool)
    indices in the list of the two volumes we want to fuse, and a bool that is true if we haven't found any intersection (by default return 0,1)
"""
    # For every surfaces i and j, check if they intersect. If yes, return i,j
    for i in range(len(parts_dimtag)-1):
        entities1 = [parts_dimtag[i]]
        for j in range(i+1, len(parts_dimtag)):
            entities2 = [parts_dimtag[j]]
            intersect = gmsh.model.occ.intersect(
                entities1, entities2, removeObject=False, removeTool=False)[0]
            gmsh.model.occ.synchronize()
            # What's missing is that he sadly doesn't recognize the intersection by a face (only volume) (but rarely a problem)

            # Check if there is an intersection (i.e. there will be a dimtag in intersect)
            if len(intersect):
                # Remove the intersection so it doesn't cause problems for meshing and others
                gmsh.model.occ.remove(intersect, True)
                gmsh.model.occ.synchronize()
                return (i, j, False)
    # There if doesn't find intersection (usually bug bc intersection of surfaces, and unlikely)
    return (0, 1, True)


def fusing_parts_and_surface_naming_for_2d_mesh(
    aircraft_parts, brep_files, cpacs, model_bb, model_dimensions
):
    """
    Function to fuse all of the different aircraft parts to get a single volume.
    Also compute which surfaces are in which volumes to be etiqueted later
    Args:
    ----------
    aircraft_parts : list of ModelPart
        List of all the parts in the airplane
    brep_files : Path
        Path of where are stocked the brep files for the airplane
    cpacs : CPACS
        CPACS object
    model_bb : list
        Contains [xmin,ymin,zmin,xmax,ymax,zmax] of bounding box of fuselage
    model_dimensions : list
        Contains [width (x-axis), length (y-axis), height (z-axis)] of fuselage
    ...
    Returns:
    ----------
    surfaces_by_part : list of list
        list of [name of brep file, tag of volume, [list of surfaces in this part], name of physical group] for all the parts in the airplane
    """
    # First we take the bounding boxes of each part
    for model_part in aircraft_parts:
        xmin, ymin, zmin, xmax, ymax, zmax = gmsh.model.occ.getBoundingBox(
            *model_part.volume)
        model_part.bounding_box = [xmin, ymin, zmin, xmax, ymax, zmax]

    # Take all the dimtag of the parts volume (vector that we will empty)
    parts_dimtag = [model_part.volume for model_part in aircraft_parts]

    # Secondly we take care of the fusion to create the airfoil
    counter = 0
    while len(parts_dimtag) > 1:
        # Choose two entities to fuse
        i, j, nointersection = intersecting_entities_for_fusing(parts_dimtag)

        # Keep count of how many times it didn't work (if error or some seperate part, could loop forever)
        if nointersection:
            counter += 1
        try:
            # Fuse them
            fused_entities, mapping = gmsh.model.occ.fuse(
                [parts_dimtag[i]], [parts_dimtag[j]]
            )
            gmsh.model.occ.synchronize()

            # Look for problems
            if len(fused_entities) > 1:
                log.info("Warning : the fusion did not give only one piece")
            if len(fused_entities) == 0:
                log.info("Warning : error, no fused entity")

            # Update the vectors of remaining entities
            parts_dimtag = [fused_entities[0]] + [
                parts_dimtag[k]
                for k in range(len(parts_dimtag))
                if k != j and k != i
            ]+fused_entities[1:]  # end should be empty but if there is a problem we let it stay

        # Handle the cases where it didn't work
        except Exception as e:
            log.info(f"Fusion failed for entities {0} and {j}: {e}")
        if counter > 10:
            log.info("Error : too many problems with order of fusion : giving up")
            break

    # Now we sort the surfaces by part (to name them & set mesh size)

    # Get all the surfaces, classified by part with bounding boxes (might take too many, will be dealt with after)
    for model_part in aircraft_parts:
        surfaces_dimtags = gmsh.model.getEntitiesInBoundingBox(
            *model_part.bounding_box, 2
        )
        surface_tags = [tag for dim, tag in surfaces_dimtags]
        model_part.surfaces = surfaces_dimtags
        model_part.surfaces_tags = surface_tags
    gmsh.model.occ.synchronize()

    # Now we deal with the ones that are in multiple bounding box --> Find in which they belong
    all_surfaces = gmsh.model.occ.getEntities(2)
    all_surfaces_tag = [s[1] for s in all_surfaces]

    # First reimport all the shapes, get their new tags and names
    newaircraft_parts = []
    for brep_file in brep_files:
        # Import the part and create the aircraft part object (and translate them as the original were translated)
        part_entities = gmsh.model.occ.importShapes(
            str(brep_file), highestDimOnly=False)
        gmsh.model.occ.translate(
            [part_entities[0]],
            -((model_bb[0]) + (model_dimensions[0] / 2)),
            -((model_bb[1]) + (model_dimensions[1] / 2)),
            -((model_bb[2]) + (model_dimensions[2] / 2)),
        )
        gmsh.model.occ.synchronize()

        part_obj = ModelPart(uid=brep_file.stem)
        part_obj.part_type = get_part_type(cpacs.tixi, part_obj.uid)
        part_obj.volume = part_entities[0]
        part_obj.volume_tag = part_entities[0][1]

        newaircraft_parts.append(part_obj)

    # Reorder the imported shape so that it is in same order than our previous ones (i.e. vectors surfaces by part and newpart name tag type have save brep name at same index)
    for i in range(len(aircraft_parts)):
        old_part = aircraft_parts[i]
        for j in range(len(newaircraft_parts)):
            new_part = newaircraft_parts[j]
            if old_part.uid == new_part.uid:
                newaircraft_parts[i], newaircraft_parts[j] = newaircraft_parts[j], newaircraft_parts[i]
                break

    # Now for each surface count in how many different part it is
    for surf in all_surfaces_tag:
        # Count all the parts surf is in
        parts_in = []
        for i in range(len(aircraft_parts)):
            model_part = aircraft_parts[i]
            for surff in model_part.surfaces_tags:
                if surff == surf:
                    parts_in.append(i)

        # Now deal with it if in more than one part
        if len(parts_in) > 1:
            for i in parts_in:
                # This is maybe overcomplicated, but gmsh doesn't keep the tags of surfaces when fused so we have to find a way to rematch them to their original part
                # Compute intersection (which is a surface) of surface with the original shape/part. If there is an intersection, it means that it is the shape that the surface was on.
                # (Precision : gmsh doesn't compute curves (or in general entity of smaller dim) at intersection for some reason, which is why it works.
                # We only get intersection if the surface is really along/inside the volume, which only happens if it is the volume it comes from.)
                intersection = gmsh.model.occ.intersect(
                    [(2, surf)], [newaircraft_parts[i].volume], removeObject=False, removeTool=False)[0]
                # Remove intersection to have a clean result
                gmsh.model.occ.remove(intersection, recursive=True)
                if len(intersection) > 0:
                    # If found, remove the tag from the others parts, and we have finished for this surface
                    for j in parts_in:
                        if j != i:
                            aircraft_parts[j].surfaces.remove((2, surf))
                            aircraft_parts[j].surfaces_tags.remove(surf)
                    break
                elif i == parts_in[-1]:
                    # If we are here, we have found no part st it is in, so there is a problem. We choose a part and hope for the best
                    log.info(
                        f"Surface{surf} still in parts{parts_in}, take off randomly")
                    for k in range(len(parts_in)-1):
                        aircraft_parts[k].surfaces.remove((2, surf))
                        aircraft_parts[k].surfaces_tags.remove(surf)
    # Remove the parts we re-imported, to get a clean result (we win't need them anymore)
    gmsh.model.occ.remove(
        [model_part.volume for model_part in newaircraft_parts], recursive=True)
    gmsh.model.occ.synchronize()

    # Now add the physical group to each part and the surfaces that are now sorted
    for model_part in aircraft_parts:
        # Just add group and name (which is the brep file without ".brep") to the surfaces of the part computed before
        part_group = gmsh.model.addPhysicalGroup(2, model_part.surfaces_tags)
        name_group = model_part.uid
        gmsh.model.setPhysicalName(2, part_group, name_group)

        # Compute the lines in each part by taking the boundary of surfaces (need them later for wing refinement)
        model_part.lines = gmsh.model.getBoundary(
            model_part.surfaces, combined=False, oriented=False)
        model_part.lines_tags = [l[1] for l in model_part.lines]

    return aircraft_parts


def pentagrow_3d_mesh(
    result_dir,
    fuselage_maxlen,
    farfield_factor,
    n_layer,
    h_first_layer,
    max_layer_thickness,
    growth_factor,
    growth_ratio,
    feature_angle,
) -> None:
    # create the config file for pentagrow
    config_penta_path = Path(result_dir, "config.cfg")
    # Variables
    InputFormat = "stl"
    NLayers = n_layer
    FeatureAngle = feature_angle
    InitialHeight = h_first_layer * (10**-5)
    MaxGrowthRatio = growth_ratio
    MaxLayerThickness = max_layer_thickness / 10
    FarfieldRadius = fuselage_maxlen * farfield_factor * 100
    FarfieldCenter = "0.0 0.0 0.0"
    OutputFormat = "cgns"
    HolePosition = "0.0 0.0 0.0"
    TetgenOptions = "-pq1.3VY"
    TetGrowthFactor = growth_factor
    HeightIterations = 8
    NormalIterations = 8
    MaxCritIterations = 128
    LaplaceIterations = 8

    # writing to file
    file = open(config_penta_path, "w")
    file.write(f"InputFormat = {InputFormat}\n")
    file.write(f"NLayers = {NLayers}\n")
    file.write(f"FeatureAngle = {FeatureAngle}\n")
    file.write(f"InitialHeight = {InitialHeight}\n")
    file.write(f"MaxGrowthRatio = {MaxGrowthRatio}\n")
    file.write(f"MaxLayerThickness = {MaxLayerThickness}\n")
    file.write(f"FarfieldRadius = {FarfieldRadius}\n")
    file.write(f"OutputFormat = {OutputFormat}\n")
    file.write(f"HolePosition = {HolePosition}\n")
    file.write(f"FarfieldCenter = {FarfieldCenter}\n")
    file.write(f"TetgenOptions = {TetgenOptions}\n")
    file.write(f"TetGrowthFactor = {TetGrowthFactor}\n")
    file.write(f"HeightIterations = {HeightIterations}\n")
    file.write(f"NormalIterations = {NormalIterations}\n")
    file.write(f"MaxCritIterations = {MaxCritIterations}\n")
    file.write(f"LaplaceIterations = {LaplaceIterations}\n")

    os.chdir("Results/GMSH")

    if os.path.exists("surface_mesh.stl"):
        log.info("surface_mesh.stl exists")
    else:
        log.warning("surface_mesh.stl does not exist")

    if os.path.exists("config.cfg"):
        log.info("config.cfg exists")
    else:
        log.warning("config.cfg does not exist")

    current_dir = os.getcwd()
    os.chdir(current_dir)

    # command = "pentagrow surface_mesh.stl config.cfg"
    command = ["pentagrow", "surface_mesh.stl", "config.cfg"]
    # Specify the file path
    file_path = "command.txt"

    command_str = " ".join(command)

    with open(file_path, "w") as file:
        file.write(command_str)

    subprocess.call(command, cwd=current_dir, start_new_session=False)

    mesh_path = Path(result_dir, "hybrid.cgns")
    log.info(f"Mesh path:{mesh_path}")

    return mesh_path
