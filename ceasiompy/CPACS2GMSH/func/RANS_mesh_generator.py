"""
CEASIOMpy: Conceptual Aircraft Design Software

Developed by CFS ENGINEERING, 1015 Lausanne, Switzerland

Use .brep files parts of an airplane to generate a fused airplane in GMSH with
the OCC kernel. Then Spherical farfield is created around the airplane and the
resulting domain is meshed using gmsh

Python version: >=3.8

| Author: Guido Vallifuoco
| Creation: 2024-02-01

TODO:

    - It may be good to move all the function and some of the code in generategmsh()
    that are related to disk actuator to another python script and import it here

    - Add mesh sizing for each aircraft part and as consequence add marker

    - Integrate other parts during fragmentation

    - Use run software function instead subprocess.call

"""

# =================================================================================================
#   IMPORTS
# =================================================================================================

import os
import subprocess
from pathlib import Path

import gmsh
from ceasiompy.CPACS2GMSH.func.generategmesh import (
    # duplicate_disk_actuator_surfaces,
    # control_disk_actuator_normal,
    # get_entities_from_volume,
    ModelPart,
    add_disk_actuator,
    fuselage_size,
    wings_size,
    process_gmsh_log,
)
from ceasiompy.utils.ceasiomlogger import get_logger

from ceasiompy.CPACS2GMSH.func.advancemeshing import (
    refine_wing_section,
    set_domain_mesh,
    min_fields,
)
from ceasiompy.CPACS2GMSH.func.wingclassification import (
    classify_wing,
)

from ceasiompy.utils.ceasiompyutils import get_part_type

from ceasiompy.utils.configfiles import ConfigFile

log = get_logger()

# =================================================================================================
#   FUNCTIONS
# =================================================================================================


def generate_2d_mesh_for_pentagrow(
    cpacs, cpacs_path, brep_dir, results_dir, open_gmsh, min_max_mesh_factor,
    fuselage_mesh_size_factor, wing_mesh_size_factor, mesh_size_engines, mesh_size_propellers,
):
    """
    Function to generate a mesh from brep files forming an airplane
    Function 'generate_gmsh' is a subfunction of CPACS2GMSH which return a
    mesh file useful for pentagrow.
    The airplane is fused with the different brep files : fuselage, wings and
    other parts are identified and fused together in order to obtain a watertight volume.
    Args:
    ----------
    cpacs : CPACS
        CPACS object
    cpacs_path : Path
        Path to the directory containing CPACS object
    brep_dir : Path
        Path to the directory containing the brep files
    results_dir : Path
        Path to the directory containing the result (mesh) files
    open_gmsh : bool
        Open gmsh GUI after the mesh generation if set to true
    min_max_mesh_factor : ?
        ? (TODO)
    fuselage_mesh_size_factor : float
        Factor of the fuselage mesh size : the mesh size will be the mean fuselage width divided by this factor
    wing_mesh_size_factor : float
        Factor of the wing mesh size : the mesh size will be the mean fuselage width divided by this factor
    mesh_size_engines : float
        Size of the engines mesh
    mesh_size_propellers : float
        Size of the propellers mesh
    ...
    Returns:
    ----------
    mesh_file : Path
        Path to the mesh file generated by gmsh


    """
    # Determine if rotor are present in the aircraft model
    rotor_model = False
    if Path(brep_dir, "config_rotors.cfg").exists():
        rotor_model = True

    if rotor_model:
        log.info("Adding disk actuator")
        config_file = ConfigFile(Path(brep_dir, "config_rotors.cfg"))
        add_disk_actuator(brep_dir, config_file)

    # Retrieve all brep
    brep_files = list(brep_dir.glob("*.brep"))
    brep_files.sort()

    # initialize gmsh
    gmsh.initialize()
    # Stop gmsh output log in the terminal
    gmsh.option.setNumber("General.Terminal", 0)
    # Log complexity
    gmsh.option.setNumber("General.Verbosity", 5)

    log.info(f"Importing files from {brep_dir}")

    # Import shapes and get the tags and name
    parts_name_tag = []
    fuselage_volume_dimtags = []
    for brep_file in brep_files:
        # Import the part and create the aircraft part object
        part_entities = gmsh.model.occ.importShapes(
            str(brep_file), highestDimOnly=False)
        gmsh.model.occ.synchronize()

        # Create the aircraft part object
        part_obj = ModelPart(uid=brep_file.stem)
        part_obj.part_type = get_part_type(cpacs.tixi, part_obj.uid)
        part_obj.physical_groups = [brep_file.name.replace('.brep', '')]
        # part_obj.
        # Want to get fuselage length to size our model
        if part_obj.part_type == "fuselage":
            fuselage_volume_dimtags.append(part_entities[0])

        # We now stock important info. We also need the name to recognize the parts when fusing (and do the matching with dimtag)
        parts_name_tag.append([brep_file.name, part_entities[0], part_obj])

    if (len(fuselage_volume_dimtags) < 1):
        # Don't know in which case it should happen but is here if needed
        model_bb = gmsh.model.get_bounding_box(-1, -1)
        log.info("Warning : no fuselage in this aircraft")
    else:
        # TODO if multiple fuselage?
        model_bb = gmsh.model.get_bounding_box(
            fuselage_volume_dimtags[0][0], fuselage_volume_dimtags[0][1]
        )

    # Compute dimensions of fuselage
    model_dimensions = [
        abs(model_bb[0] - model_bb[3]),
        abs(model_bb[1] - model_bb[4]),
        abs(model_bb[2] - model_bb[5]),
    ]
    gmsh.model.occ.synchronize()

    # Center the fuselage
    all_volumes = gmsh.model.getEntities(3)
    gmsh.model.occ.translate(
        all_volumes,
        -((model_bb[0]) + (model_dimensions[0] / 2)),
        -((model_bb[1]) + (model_dimensions[1] / 2)),
        -((model_bb[2]) + (model_dimensions[2] / 2)),
    )
    gmsh.model.occ.synchronize()

    log.info("Start manipulation to obtain a watertight volume")
    # we have to obtain a watertight volume, needed for tetgen (otherwise just can't start)

    # We then call the function to fuse the parts and create the named physical groups
    surfaces_by_part = fusing_parts_and_surface_naming_for_2d_mesh(
        parts_name_tag, brep_files, cpacs, model_bb, model_dimensions)
    gmsh.model.occ.synchronize()
    log.info("Manipulation finished")

    # Mesh generation
    log.info("Start of gmsh 2D surface meshing process")

    # Compute fuselage and wing size for meshing
    fuselage_maxlen, fuselage_minlen = fuselage_size(cpacs_path)
    wing_maxlen, wing_minlen = wings_size(cpacs_path)

    # Store the computed value to use later
    mesh_size_by_group = {}
    mesh_size_by_group["fuselage"] = (
        (fuselage_maxlen + fuselage_minlen) / 2) / fuselage_mesh_size_factor
    mesh_size_by_group["wing"] = ((wing_maxlen * 0.8 + wing_minlen) /
                                  2) / wing_mesh_size_factor
    mesh_size_by_group["engine"] = mesh_size_engines
    mesh_size_by_group["rotor"] = mesh_size_propellers

    log.info(
        f"Mesh size fuselage={  ((fuselage_maxlen + fuselage_minlen) / 2) / fuselage_mesh_size_factor :.3f} m")
    log.info(
        f"Mesh size wing={((wing_maxlen * 0.8 + wing_minlen) /2) / wing_mesh_size_factor:.3f} m")
    log.info(f"Mesh size engine={mesh_size_engines:.3f} m")
    log.info(f"Mesh size rotor={mesh_size_propellers:.3f} m")

    # Now fix the mesh size for every part
    i = 0
    for [name, tag, list_of_surfaces,  model_part, name_physical_group] in surfaces_by_part:
        i += 1
        # Take the right mesh size (name physical group should be wing or fuselage or engine or propeller)
        lc = mesh_size_by_group[name_physical_group]

        # To choose the size, we create a field with constant value containing only our list of surfaces, and give it the size
        gmsh.model.mesh.field.add("Constant", i)
        # List of surfaces should contain all the surfaces of the part
        gmsh.model.mesh.field.setNumbers(i, "SurfacesList", list_of_surfaces)
        gmsh.model.mesh.field.setNumber(i, "VIn", lc)
        gmsh.model.mesh.field.setAsBackgroundMesh(i)

    # Now we combine our fields to get the total airplane mesh
    j = i+1
    fields = [i for i in range(1, len(surfaces_by_part)+1)]
    gmsh.model.mesh.field.add("Min", j)
    gmsh.model.mesh.field.setNumbers(j, "FieldsList", fields)
    gmsh.model.mesh.field.setAsBackgroundMesh(j)
    gmsh.model.occ.synchronize()

    aircraft = ModelPart("aircraft")
    aircraft_parts = []
    for [name, tag, list_of_surfaces, model_part, name_physical_group] in surfaces_by_part:
        model_part.surfaces_tags = list_of_surfaces
        all_lines = gmsh.model.getBoundary(
            [(2, l) for l in list_of_surfaces], combined=False, oriented=False)
        model_part.lines = all_lines
        aircraft_parts.append(model_part)

    for [name, tag, list_of_surfaces, model_part, name_physical_group] in surfaces_by_part:
        model_part.surfaces_tags = list_of_surfaces
        if name_physical_group == "wing":
            classify_wing(model_part, aircraft_parts)
            log.info(
                f"Classification of {model_part.uid} done"
                f" {len(model_part.wing_sections)} section(s) found "
            )

    final_domain_volume_tag = gmsh.model.occ.getEntities(3)[0][1]
    refine_factor = 2
    if refine_factor != 1:
        mesh_fields = {"nbfields": j, "restrict_fields": [
            i for i in range(1, len(surfaces_by_part)+2)]}
        for [name, tag, list_of_surfaces, model_part, name_physical_group] in surfaces_by_part:
            if name_physical_group == "wing":
                refine_wing_section(
                    mesh_fields,
                    [final_domain_volume_tag],
                    aircraft,
                    model_part,
                    mesh_size_by_group["wing"],
                    refine=refine_factor,
                    refine_truncated=False,
                )

        # Generate the minimal background mesh field
        mesh_fields = min_fields(mesh_fields)

    # Parameters for the meshing
    gmsh.option.setNumber("Mesh.MeshSizeFromCurvature", 0)
    gmsh.option.setNumber("Mesh.MeshSizeFromPoints", 0)
    gmsh.option.setNumber("Mesh.MeshSizeExtendFromBoundary", 0)
    gmsh.option.setNumber("Mesh.Algorithm", 6)
    gmsh.option.setNumber("Mesh.LcIntegrationPrecision", 1e-6)
    gmsh.option.setNumber("Mesh.StlOneSolidPerSurface", 2)

    # Generate the mesh
    gmsh.logger.start()
    gmsh.model.mesh.generate(1)
    gmsh.model.mesh.generate(2)

    process_gmsh_log(gmsh.logger.get())
    gmsh.model.occ.synchronize()

    log.info("Finished meshing surface")
    if open_gmsh:
        log.info("Result of 2D surface mesh")
        log.info("GMSH GUI is open, close it to continue...")
        gmsh.fltk.run()

    gmesh_path = Path(results_dir, "surface_mesh.stl")
    gmsh.write(str(gmesh_path))

    return gmesh_path, fuselage_maxlen


def intersecting_entities_for_fusing(
    parts_dimtag
):
    """
Function to find two entities (volumes) in the list that have a non-zero intersection
Usefull because to fuse need connecting entities
Args:
----------
parts_dimtags :list of tuples
    List of the dimension and tag of all the volumes we want to search in
...
Returns:
----------
(i,j, True) : tuple (int,int,bool)
    indices in the list of the two volumes we want to fuse, and a bool that is true if we haven't found any intersection (by default return 0,1)
"""
    # For every surfaces i and j, check if they intersect. If yes, return i,j
    for i in range(len(parts_dimtag)-1):
        entities1 = [parts_dimtag[i]]
        for j in range(i+1, len(parts_dimtag)):
            entities2 = [parts_dimtag[j]]
            intersect = gmsh.model.occ.intersect(
                entities1, entities2, removeObject=False, removeTool=False)[0]
            gmsh.model.occ.synchronize()
            # What's missing is that he sadly doesn't recognize the intersection by a face (only volume) (but rarely a problem)

            # Check if there is an intersection (i.e. there will be a dimtag in intersect)
            if len(intersect):
                # Remove the intersection so it doesn't cause problems for meshing and others
                gmsh.model.occ.remove(intersect, True)
                gmsh.model.occ.synchronize()
                return (i, j, False)
    # There if doesn't find intersection (usually bug bc intersection of surfaces, and unlikely)
    return (0, 1, True)


def fusing_parts_and_surface_naming_for_2d_mesh(
    parts_name_tag, brep_files, cpacs, model_bb, model_dimensions
):
    """
    Function to fuse all of the different aircraft parts to get a single volume.
    Also compute which surfaces are in which volumes to be etiqueted later
    Args:
    ----------
    parts_name_tag : list of list
        List of [name of brep file, tag of volume] for all the parts in the airplane
    brep_files : Path
        Path of where are stocked the brep files for the airplane
    cpacs : CPACS
        CPACS object
    model_bb : list
        Contains [xmin,ymin,zmin,xmax,ymax,zmax] of bounding box of fuselage
    model_dimensions : list
        Contains [width (x-axis), length (y-axis), height (z-axis)] of fuselage
    ...
    Returns:
    ----------
    surfaces_by_part : list of list
        list of [name of brep file, tag of volume, [list of surfaces in this part], name of physical group] for all the parts in the airplane
    """
    # First we take the bounding boxes of each part
    bounding_boxes = {}
    for [name, dimtag, model_part] in parts_name_tag:
        xmin, ymin, zmin, xmax, ymax, zmax = gmsh.model.occ.getBoundingBox(
            dimtag[0], dimtag[1])
        bounding_boxes[name] = [dimtag, model_part,
                                (xmin, ymin, zmin, xmax, ymax, zmax)]

    # Take all the dimtag of the parts volume (vector that we will empty)
    parts_dimtag = [p_n_t[1] for p_n_t in parts_name_tag]

    # Secondly we take care of the fusion to create the airfoil
    counter = 0
    while len(parts_dimtag) > 1:
        # Choose two entities to fuse
        i, j, nointersection = intersecting_entities_for_fusing(parts_dimtag)

        # Keep count of how many times it didn't work (if error or some seperate part could loop forever)
        if nointersection:
            counter += 1
        try:
            # Fuse them
            fused_entities, mapping = gmsh.model.occ.fuse(
                [parts_dimtag[i]], [parts_dimtag[j]]
            )
            gmsh.model.occ.synchronize()

            # Look for problems
            if len(fused_entities) > 1:
                log.info("Warning : the fusion did not give only one piece")
            if len(fused_entities) == 0:
                log.info("Warning : error, no fused entity")

            # Update the vectors of remaining entities
            parts_dimtag = [fused_entities[0]] + [
                parts_dimtag[k]
                for k in range(len(parts_dimtag))
                if k != j and k != i
            ]+fused_entities[1:]  # end should be empty but if there is a problem we let it stay

        # Handle the cases where it didn't work
        except Exception as e:
            log.info(f"Fusion failed for entities {0} and {j}: {e}")
        if counter > 10:
            log.info("Error : too many problems with order of fusion : giving up")
            break

    # Now we sort the surfaces by part (to name them & set mesh size)

    # Get all the surfaces, classified by part with bounding boxes (might take too many, will be dealt with after)
    surfaces_by_part = []
    for part_name, [(dim, tag), model_part, (xmin, ymin, zmin, xmax, ymax, zmax)] in bounding_boxes.items():
        entities = gmsh.model.getEntitiesInBoundingBox(
            xmin, ymin, zmin, xmax, ymax, zmax, 2
        )
        surface_tags = [tag for dim, tag in entities]
        surfaces_by_part.append([part_name, tag, surface_tags, model_part])
    gmsh.model.occ.synchronize()

    # Now we deal with the ones that are in multiple bounding box --> Find in which they belong
    all_surfaces = gmsh.model.occ.getEntities(2)
    all_surfaces_tag = [s[1] for s in all_surfaces]

    # First reimport all the shapes, get their new tags and names
    newparts_name_tag_type = []
    for brep_file in brep_files:
        # Import the part and create the aircraft part object (and translate them as the original were translated)
        part_entities = gmsh.model.occ.importShapes(
            str(brep_file), highestDimOnly=False)
        gmsh.model.occ.translate(
            [part_entities[0]],
            -((model_bb[0]) + (model_dimensions[0] / 2)),
            -((model_bb[1]) + (model_dimensions[1] / 2)),
            -((model_bb[2]) + (model_dimensions[2] / 2)),
        )
        gmsh.model.occ.synchronize()

        part_obj = ModelPart(uid=brep_file.stem)
        part_obj.part_type = get_part_type(cpacs.tixi, part_obj.uid)

        # We also need the name of the file to recognize the parts when fusing, but also the name of the part to name physical groups
        newparts_name_tag_type.append(
            [brep_file.name, part_entities[0][1], part_obj.part_type])

    # Reorder the imported shape so that it is in same order than our previous ones (i.e. vectors surfaces by part and newpart name tag type have save brep name at same index)
    for i in range(len(surfaces_by_part)):
        for j in range(i, len(newparts_name_tag_type)):
            if surfaces_by_part[i][0] == newparts_name_tag_type[j][0]:
                newparts_name_tag_type[i], newparts_name_tag_type[j] = newparts_name_tag_type[j], newparts_name_tag_type[i]
                break

    # Now for each surface count in how many different part it is
    for surf in all_surfaces_tag:
        # Count all the parts surf is in
        parts_in = []
        for j in range(len(surfaces_by_part)):
            for surff in surfaces_by_part[j][2]:
                if surff == surf:
                    parts_in.append(j)

        # Now deal with it if in more than one part
        if len(parts_in) > 1:
            for i in parts_in:
                # This is maybe overcomplicated, but gmsh doesn't keep the tags of surfaces when fused so we have to find a way to rematch them to their original part
                # Compute intersection (which is a surface) of surface with the original shape/part. If there is an intersection, it means that it is the shape that the surface was on.
                # (Precision : gmsh doesn't compute curves (or in general entity of smaller dim) at intersection for some reason, which is why it works.
                # We only get intersection if the surface is really along/inside the volume, which only happens if it is the volume it comes from.)
                intersection = gmsh.model.occ.intersect(
                    [(2, surf)], [(3, newparts_name_tag_type[i][1])], removeObject=False, removeTool=False)[0]
                # Remove intersection to have a clean result
                gmsh.model.occ.remove(intersection, recursive=True)
                if len(intersection) > 0:
                    # If found, remove the tag from the others parts, and we have finished for this surface
                    for j in parts_in:
                        if j != i:
                            surfaces_by_part[j][2].remove(surf)
                    break
                elif i == parts_in[-1]:
                    # If we are here, we have found no part st it is in, so there is a problem. We choose a part and hope for the best
                    log.info(
                        f"Surface{surf} still in parts{parts_in}, take off randomly")
                    for k in range(len(parts_in)-1):
                        surfaces_by_part[parts_in[k]][2].remove(surf)
    # Remove the parts we re-imported, to get a clean result (we win't need them anymore)
    gmsh.model.occ.remove([(3, newparts_name_tag_type_of[1])
                           for newparts_name_tag_type_of in newparts_name_tag_type], recursive=True)
    gmsh.model.occ.synchronize()

    # Now add the physical group to each part and the surfaces that are now sorted
    for j in range(len(surfaces_by_part)):
        # Just add group and name (which is the brep file without ".brep") to the surfaces of the part computed before
        part_group = gmsh.model.addPhysicalGroup(2, surfaces_by_part[j][2])
        name_group = newparts_name_tag_type[j][0].replace('.brep', '')
        gmsh.model.setPhysicalName(2, part_group, name_group)
        surfaces_by_part[j].append(newparts_name_tag_type[j][2])

    return surfaces_by_part


def pentagrow_3d_mesh(
    result_dir,
    fuselage_maxlen,
    farfield_factor,
    n_layer,
    h_first_layer,
    max_layer_thickness,
    growth_factor,
    growth_ratio,
    feature_angle,
) -> None:
    # create the config file for pentagrow
    config_penta_path = Path(result_dir, "config.cfg")
    # Variables
    InputFormat = "stl"
    NLayers = n_layer
    FeatureAngle = feature_angle
    InitialHeight = h_first_layer * (10**-5)
    MaxGrowthRatio = growth_ratio
    MaxLayerThickness = max_layer_thickness / 10
    FarfieldRadius = fuselage_maxlen * farfield_factor * 100
    FarfieldCenter = "0.0 0.0 0.0"
    OutputFormat = "cgns"
    HolePosition = "0.0 0.0 0.0"
    TetgenOptions = "-pq1.3VY"
    TetGrowthFactor = growth_factor
    HeightIterations = 8
    NormalIterations = 8
    MaxCritIterations = 128
    LaplaceIterations = 8

    # writing to file
    file = open(config_penta_path, "w")
    file.write(f"InputFormat = {InputFormat}\n")
    file.write(f"NLayers = {NLayers}\n")
    file.write(f"FeatureAngle = {FeatureAngle}\n")
    file.write(f"InitialHeight = {InitialHeight}\n")
    file.write(f"MaxGrowthRatio = {MaxGrowthRatio}\n")
    file.write(f"MaxLayerThickness = {MaxLayerThickness}\n")
    file.write(f"FarfieldRadius = {FarfieldRadius}\n")
    file.write(f"OutputFormat = {OutputFormat}\n")
    file.write(f"HolePosition = {HolePosition}\n")
    file.write(f"FarfieldCenter = {FarfieldCenter}\n")
    file.write(f"TetgenOptions = {TetgenOptions}\n")
    file.write(f"TetGrowthFactor = {TetGrowthFactor}\n")
    file.write(f"HeightIterations = {HeightIterations}\n")
    file.write(f"NormalIterations = {NormalIterations}\n")
    file.write(f"MaxCritIterations = {MaxCritIterations}\n")
    file.write(f"LaplaceIterations = {LaplaceIterations}\n")

    os.chdir("Results/GMSH")

    if os.path.exists("surface_mesh.stl"):
        log.info("surface_mesh.stl exists")
    else:
        log.warning("surface_mesh.stl does not exist")

    if os.path.exists("config.cfg"):
        log.info("config.cfg exists")
    else:
        log.warning("config.cfg does not exist")

    current_dir = os.getcwd()
    os.chdir(current_dir)

    # command = "pentagrow surface_mesh.stl config.cfg"
    command = ["pentagrow", "surface_mesh.stl", "config.cfg"]
    # Specify the file path
    file_path = "command.txt"

    command_str = " ".join(command)

    with open(file_path, "w") as file:
        file.write(command_str)

    subprocess.call(command, cwd=current_dir, start_new_session=False)

    mesh_path = Path(result_dir, "hybrid.cgns")
    log.info(f"Mesh path:{mesh_path}")

    return mesh_path
